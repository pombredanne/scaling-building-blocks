<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Scalability Workshop</title>

	<meta name="description" content="Prepare your website for the big show.">
	<meta name="author" content="val.hoffman@gmail.com, val@tikalk.com" />
	<meta name="viewport" content="width=device-width, maximum-scale=1.0, initial-scale=1.0, user-scalable=yes" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

	<link href="css/simple.css" rel="stylesheet" type="text/css" />
	<link href="css/basic-animations.css" rel="stylesheet" type="text/css" />
	<link href="css/images.css" rel="stylesheet" type="text/css" />

	<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
	<script type="text/javascript" src="jmpress.js"></script>
</head>
<body>

<div id="simple">

	<div ~s>
		~n
		<img class="slide1 image1" src="images/slide1/ruby_logo.png"/>
		<img class="slide1 image4" src="images/slide1/nginx.png"/>
		<h1>What will be covered</h1>
		<ul>
			<li ~m>What is scalability and When it should be considered.</li>
			<li ~m>"Disk and memory is less costly than making your user wait", - Steve Huffman, Reddit</li>
			<li ~m>Concurrent massive landing</li>
			<li ~m>Good Indicator: Response time is increasing</li>
			<li ~m>Response time = Server + Network + Client</li>
		</ul>

		<h2 ~m>Who went through scaling</h2>
		<ul>
			<li ~m>Twitter, Gogobot all the big names like Shopify, Groupon etc.</li>
			<li ~m>All the other non-ruby websites like Tumblr, Instagram etc.</li>
			<li ~m>They share something common: Technology and the way it's used</li>
		</ul>

		<br/>
		<h2 ~m>Let's install some things that we'll need</h2>
		<p ~m class='code'>sudo apt-get install siege memcached redis<p>
	</div>

	<div ~s>
		~n
		<h2>Main Topics</h2>
		<ul>
			<li ~m>Caching categorized</li>
			<li ~m>Code Optimization</li>
				<ul>
					<li ~m>Profile, find bottlenecks with existing tools</li>
					<li ~m>Delayed Jobs</li>
					<li ~m>Replace software with services</li>
						<ul>
							<li ~m>Solr for search</li>
							<li ~m>Sinatra for computations etc.</li>
						</ul>
				</ul>
			<li ~m>Improve our Databases</li>
			<ul>
				<li ~m>NoSQL - Redis</li>
				<li ~m>Fine-tune existing MySQL database:</li>
					<ul>
					<li ~m>Indexes</li>
					<li ~m>Configuration</li>
					<li ~m>De-normalization</li>
					</ul>
			</ul>
			<li ~m>More tips and tricks</li>
		</ul>
	</div>

	<div ~s>
		~n
		<h2>What is web application?</h2><br/>
		<div ~m>Web applications are mainly just a... 
			<span ~m style="color:#4f4">Database</span> 
			<span ~m>PLUS some manipulation on it.</span> 
		</div>
		<div ~m>(A general and convenient concept.) </div><br/>
		<div ~m>Scaling <strong>vertically</strong> <br />
			<span ~m style="margin: 0 0 0 70px">means buying more computing power (e.g. machines) and spreading the requests among them.</span></div><br/>
		<div ~m>Scaling <strong>horizontally</strong> <br/> <span ~m style="margin: 0 0 0 70px">means improving or optimizing the code such that there's no need to scale up vertically.</span></div><br/>
		<div ~m>Can we call it scaling? Using external services like Google when including jqueury.js?</div>
	</div>

	<div ~s>
		~n
		<h1>Quick walk through our app</h1>
		<div ~m>Instead of carrying a large database, we'll just generate a few records, make relations and clone them several thousand times like so:</div>
		
		<code>
			<pre ~m>
			plast = Product.last
			for i in 0..4000
			    dupobj = plast.dup
			    dupobj.image = plast.image
			    dupobj.save!
			end
			</pre>
		</code>

		<code ~m>
			<pre ~m>
			# Populate the likes and reviews
			# 100 times randomly add likes and reviews to products
			like_ids_range = Like.first.id..Like.last.id
			review_ids_range = Review.first.id..Review.last.id
			product_ids_range = Product.first.id..Product.last.id
			for i in 1..5000
			  p = Product.find(Random.new.rand(product_ids_range))
			  p.likes << Like.find(Random.new.rand(like_ids_range))
			  p.reviews << Review.find(Random.rand(review_ids_range))
			  p.likes.first.likeability = Random.new.rand(1..5)
			  p.save!
			end
			</pre>
		</code>

		<div ~m>The scripts are located under <code>/migration/presentation</code></div>
	</div>

	<div ~s>
		~n
		<h1>Caching</h1>
		<h2 ~m>What is the problem with current app?</h2><br/>
		<div ~m>Let's dig through the server logs.</div>
		<div ~m>What is caching and how it will help.</div>
		<div ~m>How caching works. Scenario: User --> (hits) --> The Server</div>
		<br/>
		<div ~m>What are the Rails cahing types</div>
		<ul>
			<li ~m>Page - where are the stored files?</li>
			<li ~m>Action</li>
			<li ~m>Fragment</li>
			<li ~m>SQL Caching</li>
		</ul>

		<div ~m>Cache expiration - methods, sweepers, but... there’s a better way (later) and a couple of gems.</div>

	</div>

	<div ~s>
		~n
		<h2>Available Cache Stores and their difference?</h2>
		<ul>
			<li ~m>Base class: ActiveSupport::Cache::Store</li>
			<li ~m> read, write, delete, exist?, and fetch</li>
			<li ~m>FileStore</li>
			<li ~m>MemoryStore for only 1 process</li>
			<li ~m>Memcached <span ~m>use Dalli or memcache-client</span></li>
			<li ~m>Create your own, you're not limited!</li>
		</ul>
		
		<div ~m>How caching strategies can be applied on a random website</div>
	</div>


	<div ~s>
		~n
		<h2>From pure SQL to NoSQL</h2>
		<div ~m>What is Database Indexing and how it works [+ links below]. </div>
		<ul>
			<li ~m>MySQL alternatives - Postgres  / MyISAM - InnoDB with ACID http://www.wikivs.com/wiki/MySQL_vs_PostgreSQL</li>
			<li ~m>http://dev.mysql.com/doc/refman/5.5/en/optimization-indexes.html</li>
		</ul>
		<div ~m>Should we de-normalize? Pros and Cons.</div>
		<div ~m>Concepts. Key-Value - what / why </div>
		<div ~m>Open Schema: Thing + Data <br/>http://www.slideshare.net/carsonified/steve-huffman-lessons-learned-while-at-redditcom</div>
		<div ~m>Rails indexes by default :id. How do we add a migration with indexes.</div>
		<div ~m>Benchmark comparison before and after on a string search field with LIKE %abc%.</div>
		<div ~m>List of NoSQL solutions, Hadoop, MongoDB, Riak, Redis, Cassandra CouchDB etc.</div>
		<ul>
			<li ~m>Link: http://kkovacs.eu/cassandra-vs-mongodb-vs-couchdb-vs-redis</li>
			<li ~m>There’s more: http://nosql-database.org/</li>
		</ul>
	</div>

	<div ~s>
		~n
		<h2 ~m>Installing and configuring Redis on *nix and Redis and Redis-Objects gems.</h2>
		<br/>
		<div ~m>Redis commands walkthrough with $ redis-cli or $ rails c (ask)</div>
		<ul>
			<li ~m>http://redis.io/commands</li>
			<li ~m>https://github.com/nateware/redis-objects#readme</li>
			<li ~m>SADD myset “someval”, SISMEMBER myset “someval”, SMEMBERS myset</li>
			<li ~m>Let's go to redis commands page and play there.</li>
			<li ~m>For redis-objects @set = Redis::Set.new('set_name');   @set << 'a' … </li>
			<li ~m>Twitter-like example http://jimneath.org/2011/03/24/using-redis-with-ruby-on-rails.html</li>
		</ul>
		<div ~m>More advanced: </div>
		<div ~m>http://www.christianoestreich.com/2011/11/redis-hashsets-performance/</div>
		<div ~m>http://instagram-engineering.tumblr.com/post/12202313862/storing-hundreds-of-millions-of-simple-key-value-pairs</div>
	</div>


	<div ~s>
		~n
		<h1>Delayed Jobs</h1><br/>

		<div ~m>What? Why do we need them. </div>
		<div ~m>Do the minimum to end the request. The rest throw to delayed jobs.</div>
		<ul>
			<li ~m>Send emails </li> 
			<li ~m>Remove spam </li>
			<li ~m>Get data from external API </li>
			<li ~m>Update search index</li>
			<li ~m>Compute user statistics</li>
		</ul>
		<div ~m>Available gems - resque, <strong>sidekick</strong>, delayed_job advantages - performance </div>
		<ul>
			<li ~m>https://github.com/mperham/sidekiq/wiki/FAQ</li>
		</ul>
		<div ~m>Installation</div>
		<div ~m>Writing a simple worker that sends an email, execute it N times.</div>
		<div ~m>Watch the process through Web UI</div>
		<div ~m>Writing a simple worker that resizes an image.</div>
	</div>


	<div ~s>
		~n
		<h1>Solr-based Search</h1>
		<h2 ~m>What is Solr.</h2><br/>
			
		<div ~m>Solr features</div>
		<div ~m>Who uses it</div>
		<div ~m>Sunspot gem - intro how it works</div>
		<div ~m>Installation, running</div>
		<div ~m>Configuring searchable inside a model</div>
		<div ~m>Index</div>
		<div ~m>Performing a search</div>
		<div ~m>Benchmarking before and after [+ verify with below data]</div>
		<div ~m>Different configuration options e.g. make parts of a string searchable - configure schema.xml</div>
		<div ~m>Bonus - searching for similar documents, using weights</div>
		<div ~m>What about Production?</div>
	</div>


	<div ~s>
		~n
		<h1>Candies</h1>			
		<div ~m>Client-side caching, pros and cons</div>
		<div ~m>Nginx + Unicorn / Thin (What? Why not Apache)</div>
		<div ~m>JRuby</div>
		<div ~m>Sinatra services, embedding c </div>
		<div ~m>innodb_buffer_pool_size</div>
		<div ~m>Deployment with Capistrano</div>
	</div>



	<!-- benchmarks -->

	<div ~s>
		~n
		<h2>Measure the response time</h2>

		<h3 ~m>We'll use siege</h3><br/>
		<div ~m><code>siege -c50 -d10 [-t30S] -i -f site.txt</code></div><br/>

		<div ~m>(The -d NUM option sets a random interval between 0 and NUM that each "user" will sleep for between requests. While the -c NUM option sets the concurrent number of simulated users. -t: for how long to run tests or Ctrl-C)</div>

		<div ~m>site.txt is has a collection of URLs, one per line:</div><br/>

		<code>
			<pre ~m>
				http://localhost:3000/products/galery?page=1
				http://localhost:3000/products/galery?page=50
				 … 
				http://localhost:3000/products/galery?page=400
			</pre>
		</code>
		<br/>

		<div ~m>The pages URLs will be requested in random order.</div>
		
		<div ~m style="background: #eee">
			No cache:  Transaction rate:       3.72 trans/sec <span data-jmpress="drive-left after 4000ms step" style="color:#4f4"> Mmmm... not bad for an old laptop!</span><br/>
		</div>
	</div>


	<div ~s>
		~n
		<h2>Add the cache</h2>

		<h3 ~m>Add to development.rb:</h3>
		<code>
			<pre ~m> 
				config.action_controller.perform_caching = true
				config.cache_store = :file_store, "#{Rails.root}/tmp/cache"
			</pre>
		</code>

		<h3 ~m>And add to the products controller:</h3>
		<code>
			<pre ~m> 
				caches_action :galery, :cache_path => :products_cache_path.to_proc
				def products_cache_path
					current_user_id = current_user.nil?? 0 : current_user.id
					"home_index/#{params[:page]}/#{current_user_id}"
				end
			</pre>
		</code>
		<br/>
		<div ~m>
			Transaction rate:	       <strong>84.42</strong> trans/sec   <span data-jmpress="drive-left after 4000ms step" style="color:#4f4">WOW!!</span><br/>
			And once again:<br/>
			Transaction rate:	       <strong>91.20</strong> trans/sec   (Which makes sense.) <span data-jmpress="drive-left after 4300ms step" style="color:#4f4">Weee!!</span><br/><br/>
		</div>
	</div>

	<div ~s>
		~n
		<h3 ~m>Measure, compare, drive conclusions!</h3>
		<div ~m>We'll use siege and Ruby's benchmark to measure the results. Like this:</div>
		
		<code>
			<pre ~m>
			require 'benchmark'
			Benchmark.measure { 1000.times { plast.dup.save! } }
			</pre>
		</code>

		<div ~m>We're measuring the <strong>relative time</strong>. On my Lenovo ThinkPad T500 with several other processes running the results were:</div>

		<div ~m>
			=>   5.590000   0.170000   5.760000 ( 89.742811)  =SECONDS=
		</div><br/>

		<div ~m>Once again, and the results are:</div>

		<div ~m>
			=>   5.650000   0.200000   5.850000 ( 91.374391)
		</div><br/>

		<div ~m>One more time:</div>

		<div ~m>
			=>   5.540000   0.220000   5.760000 ( 96.141258)
		</div><br/>

		<div ~m> From 3 requests per second to 96, that's difference!<br/>
			89.7 -> 91.37 -> 96.14 For only one table with less than 10 columns!
		</div>
	</div>

	<div ~s>
		~n
		<h2>Switching to another cache_store.</h2>

		<code>
			<pre ~m>
				gem 'dalli'
				config.cache_store = :dalli_store
			</pre>
		</code>

		<div ~m>Transaction rate:	       89.67 trans/sec </div>
		<div ~m>No improvement :((</div>

		<div ~m>It's not surprising though. The more data you have, the more performance boost you'll feel.
		</div>

		<div ~m>
			More on the subject: <a href="http://blog.endpoint.com/2011/07/raw-caching-performance-in-rubyrails.html">read here</a><br/>
			Dali with even more parameters: <a href="https://github.com/mperham/dalli">read here</a>
		</div>
	</div>

	<div ~s>
		~n
		<div ~m><span class="code">rails s Puma</span><br/><br/>
			89.7 -> 91.37 -> 96.14 For only one table with less than 10 columns!<br/>
			Transaction rate:	       97.84 trans/sec  (Even better)<br/><br/>

			[More detailed explanation of caches_action goes here, in addition to descriptions of other caching types]<br/>
			http://guides.rubyonrails.org/caching_with_rails.html
		</div>
	</div>

	<div ~s>
		~n
		<h2>Add indices to DB</h2><br/>
		<div ~m>Indices have their own logic depending on DB. A very simple generic explanation: it’s a lookup table - instead of iteration from beginning. More detailed click <a href="http://dev.mysql.com/doc/refman/5.0/en/mysql-indexes.html">is here</a>.</div><br/>
		<code>
			<pre ~m>
			CREATE TABLE test (
			    id         INT NOT NULL,
			    last_name  CHAR(30) NOT NULL,
			    first_name CHAR(30) NOT NULL,
			    PRIMARY KEY (id),
			    INDEX name (last_name,first_name)
			);
			</pre>
		</code>
		<div ~m>The index can be used for lookups that specify values for combinations. For example: (last_name,  first_name). That index can also be used just a last_name because it is leftmost in the index.</div>
	</div>

	<div ~s>
		~n
		<h1>Utilizing Redis</h1>
		<h2>What's all the hype about?</h2>
		<h3 ~m>
			Redis is an open source, BSD licensed, advanced key-value store. It is often referred to as a data structure server since keys can contain strings, hashes, lists, sets and sorted sets.
		</h3><br/>
		<div ~m>
			In other words, Redis is an ultra-fast key-value in-memory database with lots of options used by the 'big fishes' like Twitter, Instagram, Tumblr, Flickr, Stackoverflow etc. <br/>
			Can be even more fine tuned for better performance, read about it on Instagram's developers blog.
		</div>

		<div ~m>Right after migration of likes to redis (changed only the output in products) improvement was about <strong>⅕  increase in speed</strong> (<strong>2.43</strong> trans/sec -> <strong>2.93</strong> trans/sec --> (and with reviews on redis) --> <strong>3.14</strong> trans/sec ).</div><br/>
		<div ~m>Since we’re adding complexity to our code, it’s important to use a well-defined <strong>interface</strong> (such as in the module we created) for all operations. We need to implement a Facade Design Pattern which will communicate with Redis. That way, when and if we’ll want replace Redis with something else, we will only change this Facade without the  need to search and replace the code where all the references to Redis exist. Modules could help here.</div>
		
		<div ~m><strong>Monitoring</strong></div>
		<div ~m>gem install redmon</div>
	</div>

	<div ~s>
		~n
		<h1>Web Proxy Servers</h1>
		<h2>Apache is cool, but...</h2>
		<h3 ~m>
			<strong>Nginx</strong> is a high-performance HTTP server and reverse proxy. What's in the package: high performance, stability, rich feature set, simple configuration, and low resource consumption with predictable amounts of memory under load.
		</h3><br/>
		<div ~m>
			Typical configuration might look like:
		</div>

		<code>
			<pre ~m>
upstream app {
	server unix:/srv/app/current/tmp/sockets/unicorn.sock fail_timeout=0;
}
server {
        listen   80;
        server_name  www.app.com;
        rewrite ^/(.*) http://app.com/$1 permanent;
}
		</pre>
	</code>

	</div>

	<div ~s>
		~n
		<code>
			<pre ~m>
server {
	listen 80;
	client_max_body_size 2G;
	server_name app.com;
	root /srv/app/current/public;
	access_log  off;
	error_log off;
 
	if ($request_method !~ ^(GET|HEAD|PUT|POST|DELETE|OPTIONS)$ ){
	    return 405;
	} 

	location ~ ^/(assets)/  {  
	    gzip_static on; ...
	}  

	location / {
	    try_files $uri/index.html $uri.html $uri @app;
	    error_page 404              /404.html;
	    error_page 500 502 503 504  /500.html; ...
	}

	location @app {
	    proxy_pass http://app;
	}
}
		</pre>
	</code>

	</div>

	<div ~s>
		~n
		<h2>Configuration for Memcached</h2>

		<code>
			<pre ~m>
				gem 'dalli'
				config.cache_store = :dalli_store
			</pre>
			<a href='https://github.com/datagraph/rack-throttle'>Rate limiting gem</a>
		</code>

		<div ~m>"Memcache everything", - Reddit</div>
		<ul ~m>
			<div ~m>DB data</div>
			<div ~m>Session Data</div>
			<div ~m>Rendered pages</div>
			<div ~m>Memoize internal functions</div>
		</ul>
	</div>

	<div ~s>
		~n
		<h2>Security and troubleshooting</h2>

		<div ~m>
			<a href='http://code.google.com/p/memcached/wiki/NewProgrammingTricks'>memcached tricks</a>
		</div>
		<div ~m>Supervise can restart a server when situation isn't obvious</div>
	</div>

	<div ~s>
		~n
		<h2>References</h2>
		<a href='http://highscalability.com/blog/2010/5/17/7-lessons-learned-while-building-reddit-to-270-million-page.html'>reddit lessons learned</a>
		<a href='http://www.slideshare.net/dvirsky/kicking-ass-with-redis'>Amazing Redis Patterns</a>
	</div>

</div>

<script type="text/javascript">
$(function() {
	$('#simple').jmpress();
});
</script>

</body>
</html>